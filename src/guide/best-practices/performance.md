---
outline: deep
---

# الأداء {#performance}

## نظرة عامة {#overview}

صمم Vue ليكون فعالاً في حالات الاستخدام الأكثر شيوعًا دون الحاجة إلى إجراء تحسينات يدوية. ومع ذلك ، هناك دائمًا سيناريوهات صعبة تتطلب مزيدًا من الضبط الدقيق. في هذا القسم ، سنناقش ما يجب الانتباه إليه عندما يتعلق الأمر بالأداء في تطبيق Vue.

أولاً ، دعنا نناقش الجانبين الرئيسيين لأداء الويب:

- **أداء تحميل الصفحة**: مدى سرعة عرض التطبيق للمحتوى ويصبح تفاعليًا في الزيارة الأولى. سيقاس ذلك عادةً باستخدام مقاييس الويب الحيوية مثل [أكبر رسم مضمون (LCP) Largest Contentful Paint](https://web.dev/lcp/) و [أول تأخير في الإدخال (FID) First Input Delay](https://web.dev/fid/).

- **تحديث الأداء**: مدى سرعة تحديث التطبيق استجابةً لما يدخله المستخدم. على سبيل المثال ، مدى سرعة تحديث القائمة عندما يكتب المستخدم في مربع بحث ، أو مدى سرعة تبديل الصفحة عندما ينقر المستخدم على رابط في تطبيق أحادي الصفحة (SPA).

في حين أنه سيكون من المثالي تعظيم كليهما ، تميل هياكل الواجهة المختلفة إلى التأثير على مدى سهولة تحقيق الأداء المطلوب في هذه الجوانب. بالإضافة إلى ذلك ، يؤثر نوع التطبيق الذي تقوم ببنائه بشكل كبير على ما يجب أن تحدده من أولويات الأداء. لذلك ، فإن الخطوة الأولى لضمان الأداء الأمثل هي اختيار البنية المناسبة لنوع التطبيق الذي تقوم ببنائه:

- استشر [طرق استخدام Vue](/guide/extras/ways-of-using-vue.html) لترى كيف يمكنك الاستفادة من Vue بطرق مختلفة.

- Jason Miller يناقش أنواع تطبيقات الويب والتنفيذ / التسليم المثالي لكل منها في [Application Holotypes](https://jasonformat.com/application-holotypes/).

## خيارات التحليل {#profiling-options}

لتحسين الأداء ، نحتاج أولاً إلى معرفة كيفية قياسه. هناك عدد من الأدوات الرائعة التي يمكن أن تساعد في هذا الصدد:

لتحليل أداء الحمل لعمليات نشر الإنتاج:

- [PageSpeed Insights](https://pagespeed.web.dev/)
- [WebPageTest](https://www.webpagetest.org/)

لتحليل الأداء أثناء التطوير المحلي:

- [لوحة أداء أدوات التطوير المدمجة الخاصة بChrome](https://developer.chrome.com/docs/devtools/evaluate-performance/)
  - [`app.config.performance`](/api/application.html#app-config-performance) يُمكّن علامات الأداء الخاصة بـ Vue في الجدول الزمني لأداء أدوات التطوير المدمجة الخاصة بChrome.
- [Vue DevTools Extension](/guide/scaling-up/tooling.html#browser-devtools) يوفر أيضًا ميزة تحليل ملامح الأداء.

## تحسينات تحميل الصفحة {#page-load-optimizations}

هناك العديد من الجوانب الحيادية لإطار العمل لتحسين أداء تحميل الصفحة - راجع [دليل web.dev هذا](https://web.dev/fast/) للحصول على تقرير شامل. هنا ، سنركز بشكل أساسي على التقنيات الخاصة بـ Vue.

### اختيار المخطط الصحيح {#choosing-the-right-architecture}

إذا كانت حالة الاستخدام لديك حساسة لأداء تحميل الصفحة ، فتجنب شحنها على أنها تطبيق أحادي صفحة SPA خالص من جانب العميل. تريد أن يرسل الخادم الخاص بك مباشرةً HTML يحتوي على المحتوى الذي يريد المستخدمون رؤيته. يعاني العرض الخالص من جانب العميل من بطء الوقت في الوصول إلى المحتوى. يمكن تخفيف ذلك باستخدام [التصيير من الخادم (SSR)](/guide/extras/ways-of-using-vue.html#fullstack-ssr) أو [إنشاء موقع ثابت (SSG)](/guide/extras/ways-of-using-vue.html#jamstack-ssg). تحقق من [دليل توجيه التصيير من الخادم SSR](/guide/scaling-up/ssr.html) لمعرفة المزيد حول أداء التصيير من الخادم SSR باستخدام Vue. إذا لم يكن لتطبيقك متطلبات تفاعلية غنية ، فيمكنك أيضًا استخدام خادم تقليدي لتصيير HTML وتحسينه باستخدام Vue على العميل.

إذا كان التطبيق الرئيسي الخاص بك يجب أن يكون تطبيق أحادي الصفحة SPA ، ولكن يحتوي على صفحات تسويقية (واجهة ، حول ، مدونة) ، اشحنها بشكل منفصل! يجب نشر صفحات التسويق الخاصة بك بشكل مثالي بتنسيق HTML ثابت مع الحد الأدنى من JS ، باستخدام إنشاء موقع ثابت SSG.

### حجم الحزمة و Tree-shaking {#bundle-size-and-tree-shaking}

من أكثر الطرق فعالية لتحسين أداء تحميل الصفحات هي شحن حزم JavaScript أصغر حجمًا. فيما يلي بعض الطرق لتقليل حجم الحزمة عند استخدام Vue:

- استخدم خطوة البناء إن أمكن.

  - العديد من واجهات برمجة التطبيقات الخاصة بـ Vue تكون ["tree-shakable"](https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking) إذا تجمعت عبر أداة بناء حديثة. على سبيل المثال ، إذا لم تستخدم المكوّن المدمج `<Transition>` ، فلن يتضمنه في حزمة الإنتاج النهائية. يمكن أن يؤدي Tree-shaking أيضًا إلى إزالة الوحدات النمطية الأخرى غير المستخدمة في الشيفرة المصدرية الخاصة بك.

  - عند استخدام خطوة بناء ، تجمع القوالب مسبقًا ، لذلك لا نحتاج إلى شحن مترجم Vue إلى المتصفح. هذا يوفر **14kb** علي الأقل +  ملفات JavaScript مضغوطة ويتجنب تكلفة التجميع وقت التنفيذ.

- كن حذرًا من الحجم عند إدخال إعتمادات جديدة! في التطبيقات الواقعية ، غالبًا ما تكون الحزم المتضخمة نتيجة لإدخال إعتمادات ثقيلة دون إدراك ذلك.

  - إذا كنت تستخدم خطوة بناء، ففضل الإعتمادات التي تقدم تنسيقات وحدات ES وتكون ملائمة لtree-shaking. على سبيل المثال ، يفضل `lodash-es` على `lodash`.

  - تحقق من حجم الإعتمادية وقيّم ما إذا كانت تستحق الوظيفة التي توفرها. لاحظ أنه إذا كانت الإعتمادية مناسبة لtree-shaking ، فسيعتمد زيادة الحجم على واجهات برمجة التطبيقات التي تستوردها منها. يمكن استخدام أدوات مثل [bundlejs.com](https://bundlejs.com/) لإجراء فحوصات سريعة ، ولكن القياس باستخدام إعداد البناء الفعلي سيكون دائمًا هو الأكثر دقة.

- إذا كنت تستخدم Vue بشكل أساسي للتحسين التقدمي وتفضل تجنب خطوة البناء ، ففكر في استخدام [petite-vue](https://github.com/vuejs/petite-vue) (فقط **6kb**) بدلاً من ذلك.

### تقسيم الشيفرة {#code-splitting}

تقسيم الشيفرة هو المكان الذي تقوم فيه أداة الإنشاء بتقسيم حزمة التطبيق إلى أجزاء متعددة أصغر ، والتي يمكن تحميلها عند الطلب أو بالتوازي. من خلال التقسيم المناسب للشيفرة ، يمكن تنزيل الميزات المطلوبة عند تحميل الصفحة على الفور ، مع تحميل أجزاء إضافية عند الحاجة فقط ، وبالتالي تحسين الأداء.

مجموعات مثل Rollup (التي يعتمد عليها Vite) أو webpack يمكنها إنشاء أجزاء مقسمة تلقائيًا عن طريق اكتشاف بنية الاستيراد الديناميكي لـ ESM:

```js
// lazy.js و إعتماداتها سيفصلون إلى جزء منفصل
// وستحمل فقط عند استدعاء `loadLazy()`.
function loadLazy() {
  return import('./lazy.js')
}
```

من الأفضل استخدام التحميل البطيء في الميزات غير المطلوبة فورًا بعد التحميل الأولي للصفحة. في تطبيقات Vue ، يمكن استخدام هذا مع ميزة Vue [المكون الغير متزامن](/guide/components/async.html) لإنشاء أجزاء مقسمة لأشجار المكونات:

```js
import { defineAsyncComponent } from 'vue'

//  سينشيء جزء منفصل لـ Foo.vue و إعتماداته.
// سيجلب عند الطلب فقط عند عرض المكون غير المتزامن على الصفحة.
const Foo = defineAsyncComponent(() => import('./Foo.vue'))
```

بالنسبة للتطبيقات التي تستخدم Vue Router ، يوصى بشدة باستخدام التحميل البطيء لمكونات المسار. يحتوي Vue Router على دعم صريح للتحميل البطيء ، منفصل عن `defineAsyncComponent`. راجع [مسارات التحميل البطيء](https://router.vuejs.org/guide/advanced/lazy-loading.html) للمزيد من التفاصيل.

## تحديث التحسينات {#update-optimizations}

### استقرار الدعائم {#props-stability}

في Vue ، يحدّث المكون الفرعي فقط عندما يتغير على الأقل واحد من الدعائم المستلمة. تأمل المثال التالي:

```vue-html
<ListItem
  v-for="item in list"
  :id="item.id"
  :active-id="activeId" />
```

داخل المكون `<ListItem>` ، يستخدم خاصيتي `id` و` activeId` لتحديد ما إذا كان العنصر الحالي هو العنصر النشط أم لا. أثناء نجاح ذلك ، تكمن المشكلة في أنه كلما تغيرت `activeId` ، يجب تحديث **كل** `<ListItem>` في القائمة!

من الناحية المثالية ، يجب فقط تحديث العناصر التي تغيّرت حالتها النشطة. يمكننا تحقيق ذلك عن طريق نقل حساب الحالة النشط إلى الأصل ، وجعل `<ListItem>` يقبل مباشرةً خاصية `active` بدلاً من ذلك:

```vue-html
<ListItem
  v-for="item in list"
  :id="item.id"
  :active="item.id === activeId" />
```

الآن ، بالنسبة لمعظم المكونات ، ستظل الخاصية `active` كما هي عند تغيير` activeId` ، لذلك لم تعد بحاجة إلى التحديث. بشكل عام ، الفكرة هي الحفاظ على استقرار الخاصيات التي تنتقل إلى المكونات الفرعية قدر الإمكان.

### `v-once` {#v-once}

`v-once` هو توجيه مدمج يستخدم لعرض المحتوى الذي يعتمد على بيانات وقت التنفيذ ولكنه لا يحتاج إلى التحديث مطلقًا. سيُتخطي الشجرة الفرعية sub-tree المستخدمة بالكامل لجميع التحديثات المستقبلية. استشر [مرجع واجهة برمجة التطبيق (API)](/api/built-in-directives.html#v-once) الخاص به للحصول على مزيد من التفاصيل.

### `v-memo` {#v-memo}

`v-memo` هو توجيه مدمج يمكن استخدامه شرطيا لتخطي تحديث الأشجار الفرعية sub-trees الكبيرة أو قوائم `v-for`. استشر [مرجع واجهة برمجة التطبيق (API)](/api/built-in-directives.html#v-memo) الخاص به للحصول على مزيد من التفاصيل.

## تحسينات عامة {#general-optimizations}

> تؤثر النصائح التالية على كلٍ من تحميل الصفحة و تحديث الأداء.

### افتراضية القوائم الكبيرة {#virtualize-large-lists}

أحد أكثر مشاكل الأداء شيوعًا في جميع تطبيقات الواجهة الأمامية هو عرض قوائم كبيرة. بغض النظر عن مدى أداء إطار العمل ، فإن عرض قائمة بآلاف العناصر **سيكون** بطيئًا نظرًا للعدد الهائل من عُقد DOM التي يحتاج المتصفح للتعامل معها.

لكن، لا يتعين علينا بالضرورة عرض كل هذه العقد مقدمًا. في معظم الحالات ، يمكن لحجم شاشة المستخدم عرض مجموعة فرعية صغيرة فقط من قائمتنا الكبيرة. يمكننا تحسين الأداء بشكل كبير باستخدام **افتراضية القائمة** ، وهي تقنية عرض العناصر الموجودة حاليًا أو القريبة من منفذ العرض فقط في قائمة كبيرة.

إن إنجاز افتراضية القائمة ليس بالأمر السهل ، لحسن الحظ هناك مكتبات موجودة يمكنك استخدامها مباشرة:

- [vue-virtual-scroller](https://github.com/Akryum/vue-virtual-scroller)
- [vue-virtual-scroll-grid](https://github.com/rocwang/vue-virtual-scroll-grid)
- [vueuc/VVirtualList](https://github.com/07akioni/vueuc)

### تقليل الحمل التفاعلي للهياكل الكبيرة غير القابلة للتغيير {#reduce-reactivity-overhead-for-large-immutable-structures}

نظام تفاعل Vue عميق بشكل افتراضي. على الرغم من أن هذا يجعل إدارة الحالة بديهية ، إلا أنها تنشئ مستوى معينًا من الحمل الزائد عندما يكون حجم البيانات كبيرًا ، لأن كل وصول إلى الخاصيات يقوم بتشغيل اعتراضات الوسيط التي تقوم بتتبع الإعتمادات. يصبح هذا ملحوظًا عادةً عند التعامل مع مصفوفات كبيرة من الكائنات المتداخلة بعمق ، حيث يحتاج التصيير الفردي إلى الوصول إلى أكثر من 100000 خاصية ، لذلك يجب أن يؤثر فقط على استخدام محدد للغاية.

توفر Vue فتحة هروب لإلغاء التفاعلات العميقة باستخدام [`shallowRef()`](/api/reactivity-advanced.html#shallowref) و [`shallowReactive()`](/api/reactivity-advanced.html#shallowreactive). تُنشئ واجهات برمجة التطبيقات الضحلة حالة تكون تفاعلية فقط على مستوى الجذر ، وتكشف جميع الكائنات المتداخلة كما هي. هذا يحافظ على الوصول السريع إلى الخاصيات المتداخلة ، مع مفاضلة أنه يجب علينا الآن التعامل مع جميع الكائنات المتداخلة على أنها غير قابلة للتغيير ، ولا يمكن تشغيل التحديثات إلا عن طريق استبدال حالة الجذر:

```js
const shallowArray = shallowRef([
  /* قائمة كبيرة من الكائنات العميقة */
])

// هذا لن يؤدي إلى التحديثات...
shallowArray.value.push(newObject)
// هذا يؤدي:
shallowArray.value = [...shallowArray.value, newObject]

// هذا لن يؤدي إلى التحديثات...
shallowArray.value[0].foo = 1
// هذا يؤدي:
shallowArray.value = [
  {
    ...shallowArray.value[0],
    foo: 1
  },
  ...shallowArray.value.slice(1)
]
```

### تجنب تجريد المكونات الغير الضرورية {#avoid-unnecessary-component-abstractions}

في بعض الأحيان ، قد ننشئ [مكونات بدون عرض](/guide/components/slots.html#renderless-components) أو مكونات أعلي مرتبة (أي مكونات تقدم مكونات أخرى مع خاصيات إضافية) من أجل تجريد أفضل أو تنظيم للشيفرة. على الرغم من عدم وجود خطأ في هذا الأمر ، ضع في اعتبارك أن نسخ المكون أغلى بكثير من عقد DOM العادية ، وأن إنشاء الكثير منها بسبب أنماط التجريد سيكبد تكاليف الأداء.

لاحظ أن تقليل عدد قليل فقط من النسخ لن يكون له تأثير ملحوظ ، لذلك لا تقلق إذا عرض المكون عدة مرات فقط في التطبيق. أفضل سيناريو للنظر في هذا التحسين هو مرة أخرى في القوائم الكبيرة. تخيل قائمة تضم 100 عنصر حيث يحتوي كل مكون عنصر على العديد من المكونات الفرعية. قد تؤدي إزالة أحد عناصر التجريد غير الضرورية هنا إلى تقليل مئات نسخ المكون.
