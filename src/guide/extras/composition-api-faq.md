---
outline: deep
---

# الأسئلة الشائعة حول الواجهة التركيبية {#composition-api-faq}

:::tip ملاحظة
نفترض في هذا الدليل أن يكون لديك خبرة سابقة مع Vue - وبالتحديد، خبرة مع Vue 2 أثناء استخدام واجهة  الخيارات بشكل أساسي.
:::

## ماهي الواجهة التركيبية؟ {#what-is-composition-api}

<VueSchoolLink href="https://vueschool.io/lessons/introduction-to-the-vue-js-3-composition-api" title="درس مجاني حول الواجهة التركيبية"/>

الواجهة التركيبية هي مجموعة من الواجهات البرمجية التي تسمح لنا بكتابة مكونات Vue باستخدام دوال مستوردة بدلاً من التصريح بالخيارات. وهي مصطلح  يغطي الواجهات البرمجية التالية:

- [الواجهة البرمجية التفاعلية](/api/reactivity-core)، على سبيل المثال `()ref` و `()reactive`، والتي تسمح لنا مباشرة بإنشاء حالة تفاعلية، حالة محسوبة، ودوال مراقبة.

- [خطافات دورة الحياة](/api/composition-api-lifecycle)، على سبيل المثال `()onMounted` و `()onUnmounted`، والتي تسمح لنا بربط الدوال بشكل برمجي مع دورة حياة المكون.

- [حقن الاعتمادية](/api/composition-api-dependency-injection)، أي `()provide` و `()inject`، والتي تسمح لنا بالاستفادة من نظام حقن الاعتمادية في Vue أثناء استخدام الواجهات البرمجية التفاعلية.

لواجهة التركيبية هي ميزة مدمجة في Vue 3 و [Vue 2.7](https://blog.vuejs.org/posts/vue-2-7-naruto.html). لإصدارات Vue 2 الأقدم،  استخدم الملحق [`vue/composition-api@`](https://github.com/vuejs/composition-api). في Vue 3، يستخدم أيضًا بشكل أساسي مع صيغة [`<script setup>`](/api/sfc-script-setup) في المكونات أحادية الملف. هنا مثال أساسي لمكون يستخدم الواجهة التركيبية:

```vue
<script setup>
import { ref, onMounted } from 'vue'

// حالة تفاعلية
const count = ref(0)

// دوال تغيير الحالة وتحفيز التحديثات
function increment() {
  count.value++
}

// خطافات دورة الحياة
onMounted(() => {
  console.log(`العداد الأولي هو ${count.value}.`)
})
</script>

<template>
  <button @click="increment">قيمة العداد: {{ count }}</button>
</template>
```

على الرغم من أن الواجهة التركيبية تعتمد على أسلوب وظيفي يعتمد على تركيب الدوال، **إلا أن الواجهة التركيبية ليست برمجة وظيفية**. تعتمد الواجهة التركيبية على نموذج التفاعلية الدقيقة والقابلة للتغيير في Vue، بينما ترتكز البرمجة الوظيفية على عدم التغيير.

إذا كنت مهتمًا بتعلم كيفية استخدام Vue مع الواجهة التركيبية، يمكنك تعيين تفضيل   الواجهة التركيبية في كامل الموقع باستخدام مفتاح التبديل في أعلى الشريط الجانبي الأيسر، ثم الانتقال إلى الدليل من البداية.

## لماذا الواجهة التركيبية {#why-composition-api}

### إعادة استخدام الشيفرة البرمجية بشكل أفضل {#better-logic-reuse}

الميزة الأساسية للواجهة التركيبية هي أنها تمكن إعادة استخدام الشيفرة البرمجية النظيفة والفعالة في شكل [دوال تركيبية](/guide/reusability/composables). وهي تحل [جميع عيوب المخلوطات](/guide/reusability/composables#vs-mixins)، والتي تعتبر آلية إعادة استخدام الشيفرة البرمجية الأساسية في واجهة الخيارات.

قدرة إعادة استخدام الشيفرة البرمجية في الواجهة التركيبية أدت إلى ظهور مشاريع مجتمعية مثيرة مثل [VueUse](https://vueuse.org/)، وهي مجموعة من الأدوات التركيبية المتنامية باستمرار. كما أنها تعمل كآلية نظيفة لدمج الخدمات أو المكتبات الخارجية ذات الحالة في نظام التفاعلية في Vue بسهولة، على سبيل المثال [البيانات غير القابلة للتغيير](/guide/extras/reactivity-in-depth#immutable-data)، [الآلات الحالية](/guide/extras/reactivity-in-depth#state-machines)، و [RxJS](/guide/extras/reactivity-in-depth#rxjs).

### تنظيم أكثر مرونة للشيفرات {#more-flexible-code-organization}

يحب العديد من المستخدمين أن نكتب شيفرة منظمة بشكل افتراضي مع واجهة الخيارات: كل شيء له مكانه بناءً على الخيار الذي ينبني عليه. ومع ذلك، تفرض واجهة الخيارات قيودًا جديو عندما تتجاوز الشيفرة البرمجية لمكون واحد حدًا معينًا من التعقيد. وهذا القيد بارز بشكل خاص في المكونات التي تحتاج إلى التعامل مع العديد من **الوظائف المنطقية**، والتي شهدناها بشكل مباشر في العديد من تطبيقات Vue 2 التي تشتغل في طور الإنتاج.

خذ مكون مستكشف المجلدات من الواجهة الرسومية الخاصة بـ Vue CLI كمثال: هذا المكون مسؤول عن الوظائف المنطقية التالية:

- تتبع حالة المجلد الحالي وعرض محتوياته
- التعامل مع تصفح المجلدات (فتح، إغلاق، تحديث...)
- التعامل مع إنشاء مجلد جديد     
- التبديل إلى عرض المجلدات المفضلة فقط
- التبديل إلى عرض المجلدات المخفية
- التعامل مع تغييرات مجلد العمل الحالي

النسخة [الأصلية](https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L198-L404) من المكون كتبت بواجهة الخيارات. إذا أعطينا كل سطر من الشيفرة لونًا بناءً على الوظيفة المنطقية التي يتعامل معها، هذا هو شكله:

<img alt="folder component before" src="./images/options-api.png" width="129" height="500" style="margin: 1.2em auto">

لاحظ كيف تُجبر الشيفرة التي تتعامل مع نفس الوظيفة المنطقية على الانقسام تحت خيارات مختلفة، وتقع في أجزاء مختلفة من الملف. في مكون يتكون من عدة مئات من الأسطر، يتطلب فهم وتصفح وظيفة منطقية واحدة التمرير بين الأعلى والأسفل باستمرار، مما يجعل المهمة أكثر صعوبة مما ينبغي. بالإضافة إلى ذلك، إذا كنا ننوي استخراج وظيفة منطقية إلى أداة قابلة لإعادة الاستخدام، فإنها تتطلب الكثير من العمل لإيجاد واستخراج الأجزاء المناسبة من الشيفرة من أجزاء مختلفة من الملف.

هنا نفس المكون قبل وبعد [إعادة هيكلته يالواجهة التركيبية](https://gist.github.com/yyx990803/8854f8f6a97631576c14b63c8acd8f2e):

![شكل مكون المتصفح بعد الهيكلة](./images/composition-api-after.png)

لاحظ كيف يمكن تجميع الشيفرة المتعلقة بنفس الوظيفة المنطقية معًا الآن: لم نعد بحاجة إلى القفز بين كتل الخيارات المختلفة أثناء العمل على وظيفة منطقية محددة. علاوة على ذلك، يمكننا الآن نقل مجموعة من الشيفرة إلى ملف خارجي بجهد أدنى، لأننا لم نعد بحاجة إلى ترتيب الشيفرة من أجل استخراجها. هذا الاحتكاك المنخفض لإعادة الترتيب أمر أساسي لقابلية الصيانة على المدى الطويل في مجموعات الشيفرة الكبيرة.

### استنباط أفضل للأنواع {#better-type-inference}

في السنوات الأخيرة، تبنى الكثير من مطوري الواجهة الأمامية [TypeScript](https://www.typescriptlang.org/) لأنه يساعدنا على كتابة شيفرة أكثر صلابة، وإجراء التغييرات بثقة أكبر، ويوفر تجربة تطوير رائعة مع دعم المحررات. ومع ذلك، واجهة الخيارات التي صممت في الأصل عام 2013، دون الأخذ في الاعتبار استنباط الأنواع. كان علينا تنفيذ بعض [التمارين  المعقدة بشكل سخيف](https://github.com/vuejs/core/blob/44b95276f5c086e1d88fa3c686a5f39eb5bb7821/packages/runtime-core/src/componentPublicInstance.ts#L132-L165) لجعل استنباط الأنواع يعمل مع واجهة الخيارات. حتى مع كل هذا الجهد، يمكن أن يتعطل استنباط الأنواع لواجهة الخيارات في المخاليط وحقن الإعتمادية.

هذا ما أدى بالعديد من المطورين الذين يريدون استخدام Vue مع TS يميلون نحو واجهة البرمجة الكائنية التي تعمل بواسطة `vue-class-component`. ومع ذلك، تعتمد واجهة البرمجة الكائنية بشكل كبير على مزيد من ES decorators، وهي ميزة لغة كانت مقترحة مرحلة 2 فقط عندما كان تم البدء في تطوير Vue 3 في عام 2019. شعرنا أنه من المخاطرة جدًا أن نقوم بتأسيس واجهة برمجة رسمية على مقترح غير مستقر. منذ ذلك الحين، مر مقترح decorators بتغييرات كاملة أخرى، ووصل أخيرًا إلى المرحلة 3 في عام 2022. بالإضافة إلى ذلك، تعاني واجهة البرمجة الكائنية من قيود إعادة استخدام الشيفرة وتنظيمها مماثلة لواجهة الخيارات.

بالمقارنة، تستخدم واجهة البرمجة التركيبية متغيرات ودوال عادية بشكل أساسي، والتي تكون ودية للأنواع بشكل طبيعي. يمكن للشيفرة المكتوبة في واجهة البرمجة التركيبية الاستمتاع بالاستنباط الكامل للأنواع مع القليل من الحاجة إلى تلميحات الأنواع اليدوية. في معظم الأوقات، ستبدو الشيفرة المكتوبة في واجهة البرمجة التركيبية متطابقة تمامًا في TypeScript و JavaScript العادي. وهذا أيضًا يجعل من الممكن على مستخدمي JavaScript العادي الاستفادة من استنباط الأنواع الجزئي.

### حزمة إنتاج أصغر وتكاليف أقل {#smaller-production-bundle-and-less-overhead}

الشيفرة المكتوبة بواجهة البرمجة التركيبية و صسغى `<script setup>` أكثر كفاءة ودية للتقليل من حجمها مقارنة  بما يعادلها في واجهة الخيارات. هذا لأن القالب في عنصر `<script setup>` يترجم كدالة مضمنة في نفس نطاق شيفرة `<script setup>`. على عكس الوصول إلى الخاصية من `this`، يمكن لشيفرة القالب المترجمة الوصول مباشرة إلى المتغيرات المعلنة داخل `<script setup>`، دون وجود نسخة وسيط بينهما. وهذا أيضًا يؤدي إلى تقليل حجم الشيفرة بشكل أفضل لأن جميع أسماء المتغيرات يمكن تقليلها بأمان.

## العلاقة مع واجهة الخيارات {#relationship-with-options-api}

### التجاذبات {#trade-offs}

بعض المستخدمين الذين ينتقلون من واجهة الخيارات وجدوا أن شيفرة الواجهة التركيبية أقل تنظيمًا، واستنتجوا أن الواجهة التركيبية "أسوأ" من حيث تنظيم الشيفرة. نوصي المستخدمين الذين لديهم مثل هذه الآراء بالنظر إلى هذه المشكلة من منظور مختلف.

صحيح أن الواجهة التركيبية لم تعد توفر "حواجز الحماية" التي توجهك لوضع شيفرتك في الحاويات المناسبة. وبالمقابل، يمكنك كتابة شيفرة المكون كما لو كنت تكتب JavaScript عادي. وهذا يعني **يمكنك ويجب عليك تطبيق أي ممارسات أفضل لتنظيم الشيفرة على شيفرة الواجهة التركيبية كما تفعل عند كتابة JavaScript عادي**. إذا كنت تستطيع كتابة JavaScript منظم، يجب أن تكون قادرًا أيضًا على كتابة شيفرة منظمة بالواجهة التركيبية .

واجهة الخيارات تسمح لك بـ "التفكير أقل" عند كتابة شيفرة المكون، وهذا هو السبب في أن العديد من المستخدمين يحبونها. ومع ذلك، في تقليل العبء الذهني، فإنه يقفلك في نمط تنظيم الشيفرة المحدد دون وجود مخرج، مما يجعل من الصعب إعادة ترتيب الشيفرة أو تحسين جودة الشيفرة في مشاريع أكبر حجمًا. من هذا المنطلق، توفر الواجهة التركيبية قابلية توسع أفضل على المدى الطويل.

### هل تغطي الواجهة التركيبية جميع حالات الاستخدام؟ {#does-composition-api-cover-all-use-cases}

هناك خيارات قليلة فقط قد تكون ما زالت مطلوبة: `props`، `emits`، `name`، و `inheritAttrs`. إذا كنت تستخدم `<script setup>`، فإن `inheritAttrs` هو الخيار الوحيد الذي قد يتطلب كتلة `<script>` عادية منفصلة.

:::tip

منذ 3.3 يمكنك استخدام `defineOptions` مباشرة في `<script setup>` لتعيين اسم المكون أو خاصية `inheritAttrs`

:::

If you intend to exclusively use Composition API (along with the options listed above), you can shave a few kbs off your production bundle via a [compile-time flag](/api/compile-time-flags) that drops Options API related code from Vue. Note this also affects Vue components in your dependencies.

### هل يمكنني استخدام الواجهتين مع بعض؟ {#can-i-use-both-apis-together}

نعم. يمكنك استخدام واجهة التركيبية عبر الخيار [`setup()`](/api/composition-api-setup) في مكون واجهة الخيارات.

ومع ذلك، نوصي فقط بالقيام بذلك إذا كان لديك قاعدة شيفرات موجودة بالفعل تحتاج إلى التكامل مع ميزات / مكتبات خارجية جديدة مكتوبة بالواجهة التركيبية.

### هل ستُلغى واجهة الخيارات؟ {#will-options-api-be-deprecated}

لا، ليس لدينا أي خطة للقيام بذلك. واجهة الخيارات هي جزء لا يتجزأ من Vue والسبب في ذلك أن العديد من المطورين يحبونها. ندرك أيضًا أن العديد من فوائد الواجهة التركيبية تظهر فقط في المشاريع ذات المستوى الأكبر، وواجهة الخيارات لا تزال خيارًا متينًا للعديد من السيناريوهات ذات المستوى المنخفض إلى المتوسط.

## العلاقة مع واجهة الكائنية {#relationship-with-class-api}

نحن لم نعد نوصي باستخدام الواجهة الكائنية مع Vue 3، نظرًا لأن الواجهة التركيبية توفر تكاملًا رائعًا مع TypeScript مع فوائد إعادة الاستخدام الإضافية للشيفرة وتنظيمها.

## المقارنة مع خطافات React {#comparison-with-react-hooks}

الواجهة التركيبية توفر نفس مستوى قدرات تركيب الشيفرة مثل خطافات React، ولكن مع بعض الاختلافات المهمة.

خطافات React تستدعى مرارًا وتكرارًا في كل مرة يُحدث فيها المكون. هذا يخلق عددًا من الحالات التي يمكن أن تربك حتى المطورين المتمرسين في React. كما أنه يؤدي إلى مشاكل تحسين الأداء التي يمكن أن تؤثر بشكل كبير على تجربة التطوير. وإليك بعض الأمثلة:

- الخطافات حساسة لترتيب الاستدعاء ولا يمكن أن تكون شرطية.

- يمكن أن تُلتقط المتغيرات المعلنة في مكون React بواسطة مغلف الخطاف وتصبح "غير صالحة" إذا فشل المطور في تمرير مصفوفة الاعتماديات الصحيحة. وهذا يؤدي إلى أن يعتمد مطورو React على قواعد ESLint لضمان تمرير الاعتماديات الصحيحة. ومع ذلك، فإن القاعدة غالبًا ليست ذكية بما فيه الكفاية وتعوض عن الصحة، مما يؤدي إلى إلغاء غير ضروري وصداع عند مواجهة حالات قصوى.

- تتطلب العمليات الحسابية المكلفة استخدام `useMemo`، والذي يتطلب مرة أخرى تمرير مصفوفة الاعتماديات الصحيحة يدويًا.

- يتسبب معالجو الأحداث الممررة إلى المكونات الأبناء في تحديثات غير ضرورية للأبناء افتراضيًا، ويتطلب استخدام `useCallback` بشكل صريح كتحسين. وهذا مطلوب تقريبًا دائمًا، ويتطلب مرة أخرى مصفوفة الاعتماديات الصحيحة. وإهمال هذا يؤدي إلى إعادة تصيير التطبيقات افتراضيًا ويمكن أن يتسبب في مشاكل في الأداء دون أن ندرك ذلك.

- مشكلة المغلف الغير صالح، مجتمعة مع الميزات المتزامنة، تجعل من الصعب التفكير في متى تشغل قطعة من شيفرة الخطافات، وتجعل العمل مع الحالة القابلة للتغيير التي يجب أن تستمر عبر التصييرات (عبر `useRef`) مرهقة.

> Note: some of the above issues that are related to memoization can be resolved by the upcoming [React Compiler](https://react.dev/learn/react-compiler).

In comparison, Vue Composition API:

- تستدعي شيفرة `()setup` أو `<script setup>` مرة واحدة فقط. وهذا يجعل الشيفرة تتوافق بشكل أفضل مع الحدس المتعلق باستخدام JavaScript النمطي لأنه لا توجد مغلفات غير صالحة للقلق بشأنها. كما أن استدعاء الواجهة التركيبية ليس حساسًا لترتيب الاستدعاء ويمكن أن يكون شرطيًا.

- يجمع نظام التفاعلية في وقت التشغيل في Vue تلقائيًا الاعتماديات التفاعلية المستخدمة في الخاصيات المحسوبة والمراقبة، لذا لا حاجة لإعلان الاعتماديات يدويًا.

- لا حاجة لتخزين مؤقت لدوال رد النداء يدويًا لتجنب تحديثات الأبناء غير الضرورية. بشكل عام، يضمن نظام التفاعلية الدقيق في Vue أن تُحدث المكونات الأبناء فقط عندما يكون ذلك ضروريًا. وتحسينات تحديث الأبناء يدويًا نادرًا ما تكون مصدر قلق لمطوري Vue.

نقرّ بالاعتراف بالإبداع في خطافات React، وهي مصدر إلهام رئيسي للواجهة التركيبية. ومع ذلك، فإن المشاكل المذكورة أعلاه موجودة في تصميمها ولوحظ أن نموذج التفاعلية في Vue يوفر طريقة للتغلب عليها.
