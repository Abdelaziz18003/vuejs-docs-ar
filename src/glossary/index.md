# مسرد {#glossary}

يهدف هذا القاموس إلى تقديم بعض الإرشادات حول معاني المصطلحات الفنية الشائعة الاستخدام عند الحديث عن Vue. والغرض من هذا القاموس هو أن يكون *وصفيًا* لكيفية استخدام المصطلحات بشكل شائع، وليس تحديدًا *إرشاديًا* لكيفية استخدامها. قد يكون لبعض المصطلحات معاني أو فروق دقيقة مختلفة قليلاً حسب السياق المحيط.

[[TOC]]

## مكون غير متزامن {#async-component}

*المكون غير المتزامن* عبارة عن غلاف حول مكون آخر يسمح بتحميل المكون المغلف بشكل كسول. يستخدم هذا عادةً كطريقة لتقليل حجم ملفات `.js` المبنية، مما يسمح بتقسيمها إلى أجزاء أصغر يتم تحميلها فقط عند الحاجة.

يحتوي Vue Router على ميزة مماثلة [للتحميل البطيء لمكونات المسار](https://router.vuejs.org/guide/advanced/lazy-loading.html)، على الرغم من أن هذا لا يستخدم ميزة مكونات Vue غير المتزامنة.

لمزيد من التفاصيل، راجع:
- [دليل - المكونات غير المتزامنة](/guide/components/async.html)

## الماكرو المترجم {#compiler-macro}

*ماكرو المترجم* هو كود خاص تتم معالجته بواسطة المترجم وتحويله إلى شيء آخر. إنها في الواقع شكل ذكي من أشكال استبدال السلسلة.

يدعم المترجم [SFC](#single-file-component) من Vue وحدات ماكرو مختلفة، مثل `defineProps()` و`defineEmits()` و`defineExpose()`. تم تصميم وحدات الماكرو هذه عمدًا لتبدو مثل وظائف JavaScript العادية حتى تتمكن من الاستفادة من نفس أدوات التحليل واستنتاج النوع حول JavaScript / TypeScript. ومع ذلك، فهي ليست وظائف فعلية يتم تشغيلها في المتصفح. هذه هي سلاسل خاصة يكتشفها المترجم ويستبدلها بكود JavaScript الحقيقي الذي سيتم تشغيله بالفعل.

وحدات الماكرو لها قيود على استخدامها لا تنطبق على كود JavaScript العادي. على سبيل المثال، قد تعتقد أن `const dp = defineProps` يسمح لك بإنشاء اسم مستعار لـ `defineProps`، لكن هذا سيؤدي في الواقع إلى حدوث خطأ. هناك أيضًا قيود على القيم التي يمكن تمريرها إلى `defineProps()`، حيث يتعين معالجة 'الحجج' بواسطة المترجم وليس في وقت التشغيل.

لمزيد من التفاصيل، راجع:
- [`<script setup>` - `defineProps()` & `defineEmits()`](/api/sfc-script-setup.html#defineprops-defineemits)
- [`<script setup>` - `defineExpose()`](/api/sfc-script-setup.html#defineexpose)

## عنصر {#component}

لا يقتصر مصطلح *المكون* على Vue. فهو شائع في العديد من أطر عمل واجهة المستخدم. وهو يصف جزءًا من واجهة المستخدم، مثل الزر أو مربع الاختيار. ويمكن أيضًا دمج المكونات لتكوين مكونات أكبر.

المكونات هي الآلية الأساسية التي توفرها Vue لتقسيم واجهة المستخدم إلى أجزاء أصغر، سواء لتحسين إمكانية الصيانة أو للسماح بإعادة استخدام التعليمات البرمجية.

مكون Vue هو كائن. جميع الخصائص اختيارية، ولكن يلزم وجود قالب أو وظيفة عرض حتى يتم عرض المكون. على سبيل المثال، سيكون الكائن التالي مكونًا صالحًا:

```js
const HelloWorldComponent = {
render() {
return 'مرحبا بالعالم!'
}
}
```

في الممارسة العملية، تتم كتابة معظم تطبيقات Vue باستخدام [Single-File Components](#single-file-component) (ملفات `.vue`). ورغم أن هذه المكونات قد لا تبدو وكأنها كائنات للوهلة الأولى، فإن مُجمِّع SFC سيحولها إلى كائن، والذي يُستخدم كتصدير افتراضي للملف. ومن منظور خارجي، فإن ملف `.vue` هو مجرد وحدة ES تقوم بتصدير كائن مكون.

وعادةً ما يشار إلى خصائص كائن المكون باسم *options*. ومن هنا جاء اسم [Options API](#options-api).

تحدد خيارات المكون كيفية إنشاء مثيلات لهذا المكون. المكونات تشبه مفاهيميًا الفئات، على الرغم من أن Vue لا تستخدم فئات JavaScript الفعلية لتعريفها.

يمكن أيضًا استخدام مصطلح المكون بشكل أكثر مرونة للإشارة إلى مثيلات المكون.

لمزيد من التفاصيل، راجع:
- [دليل - أساسيات المكونات](/guide/essentials/component-basics.html)

تظهر كلمة "مكون" أيضًا في العديد من المصطلحات الأخرى:
- [مكون غير متزامن](#async-component)
- [مكون ديناميكي](#dynamic-component)
- [مكون وظيفي](#functional-component)
- [مكون ويب](#web-component)

## قابلة للتأليف {#composable}

يصف مصطلح *composable* نمط استخدام شائع في Vue. إنه ليس ميزة منفصلة لـ Vue، بل هو مجرد طريقة لاستخدام [Composition API](#composition-api) للإطار.

* composable هو دالة.
* تُستخدم composables لتغليف وإعادة استخدام المنطق المرتبط بالحالة.
* يبدأ اسم الدالة عادةً بـ `use`، حتى يعرف المطورون الآخرون أنها composable.
* من المتوقع عادةً استدعاء الدالة أثناء التنفيذ المتزامن لدالة `setup()` الخاصة بالمكون (أو على نحو مكافئ، أثناء تنفيذ كتلة `<script setup>`). يربط هذا استدعاء composable بسياق المكون الحالي، على سبيل المثال عبر استدعاءات `provide()` أو `inject()` أو `onMounted()`.
* عادةً ما تعيد composables كائنًا عاديًا، وليس كائنًا تفاعليًا. عادةً ما يحتوي هذا الكائن على مراجع ووظائف ومن المتوقع أن يتم تفكيكه داخل الكود المستدعي.

كما هو الحال مع العديد من الأنماط، قد يكون هناك بعض الخلاف حول ما إذا كان الكود المحدد مؤهلاً للتسمية. ليست كل وظائف الأداة المساعدة في JavaScript قابلة للتكوين. إذا كانت الوظيفة لا تستخدم واجهة برمجة التطبيقات للتكوين، فربما لا تكون قابلة للتكوين. إذا لم تكن تتوقع استدعاؤها أثناء التنفيذ المتزامن لـ `setup()`، فربما لا تكون قابلة للتكوين. تُستخدم العناصر القابلة للتكوين على وجه التحديد لتغليف المنطق ذي الحالة، وهي ليست مجرد اتفاقية تسمية للوظائف.

راجع [الدليل - العناصر القابلة للتكوين](/guide/reusability/composables.html) لمزيد من التفاصيل حول كتابة العناصر القابلة للتكوين.

## تكوين API {#composition-api}

*Composition API* عبارة عن مجموعة من الوظائف المستخدمة لكتابة المكونات والعناصر القابلة للتكوين في Vue.

يُستخدم المصطلح أيضًا لوصف أحد الأسلوبين الرئيسيين المستخدمين لكتابة المكونات، والأسلوب الآخر هو [Options API](#options-api). تستخدم المكونات المكتوبة باستخدام Composition API إما `<script setup>` أو وظيفة صريحة `setup()`.

راجع [Composition API FAQ](/guide/extras/composition-api-faq) لمزيد من التفاصيل.

## عنصر مخصص {#custom-element}

*العنصر المخصص* هو ميزة من ميزات معيار [Web Components](#web-component)، والذي يتم تنفيذه في متصفحات الويب الحديثة. يشير إلى القدرة على استخدام عنصر HTML مخصص في ترميز HTML الخاص بك لتضمين عنصر ويب في تلك النقطة في الصفحة.

يحتوي Vue على دعم مدمج لعرض العناصر المخصصة ويسمح باستخدامها مباشرة في قوالب مكونات Vue.

لا ينبغي الخلط بين العناصر المخصصة والقدرة على تضمين مكونات Vue كعلامات داخل قالب مكون Vue آخر. تُستخدم العناصر المخصصة لإنشاء مكونات ويب، وليس مكونات Vue.

لمزيد من التفاصيل، راجع:
- [الدليل - Vue ومكونات الويب](/guide/extras/web-components.html)

## توجيه {#directive}

يشير مصطلح *التوجيه* إلى سمات القالب التي تبدأ بالبادئة `v-` أو الاختصارات المكافئة لها.

تتضمن التوجيهات المضمنة `v-if` و`v-for` و`v-bind` و`v-on` و`v-slot`.

يدعم Vue أيضًا إنشاء توجيهات مخصصة، على الرغم من أنها تُستخدم عادةً فقط كـ "منفذ هروب" للتعامل مع عقد DOM بشكل مباشر. لا يمكن استخدام التوجيهات المخصصة عمومًا لإعادة إنشاء وظائف التوجيهات المضمنة.

لمزيد من التفاصيل، راجع:
- [دليل - بناء جملة القالب - التوجيهات](/guide/essentials/template-syntax.html#directives)
- [دليل - التوجيهات المخصصة](/guide/reusability/custom-directives.html)

## مكون ديناميكي {#dynamic-component}

يُستخدم مصطلح *المكون الديناميكي* لوصف الحالات التي يلزم فيها اختيار المكون الفرعي المراد عرضه ديناميكيًا. وعادةً ما يتم تحقيق ذلك باستخدام `<component :is="type">`.

لا يعد المكون الديناميكي نوعًا خاصًا من المكونات. يمكن استخدام أي مكون كمكون ديناميكي. إن اختيار المكون هو الذي يكون ديناميكيًا، وليس المكون نفسه.

لمزيد من التفاصيل، راجع:
- [دليل - أساسيات المكونات - المكونات الديناميكية](/guide/essentials/component-basics.html#dynamic-components)

## تأثير {#effect}

شاهد [تأثير تفاعلي](#reactive-effect) و [تأثير جانبي](#side-effect).

## حدث {#event}

إن استخدام الأحداث للتواصل بين أجزاء مختلفة من البرنامج أمر شائع في العديد من مجالات البرمجة المختلفة. داخل Vue، يتم تطبيق المصطلح بشكل شائع على أحداث عناصر HTML الأصلية وأحداث مكونات Vue. يتم استخدام التوجيه `v-on` في القوالب للاستماع إلى كلا النوعين من الأحداث.

لمزيد من التفاصيل، راجع:
- [دليل - التعامل مع الأحداث](/guide/essentials/event-handling.html)
- [دليل - أحداث المكونات](/guide/components/events.html)

## جزء {#fragment}

يشير مصطلح *fragment* إلى نوع خاص من [VNode](#vnode) يُستخدم كأصل لعقد VNodes أخرى، ولكنه لا يعرض أي عناصر بنفسه.

يأتي الاسم من مفهوم مشابه لـ [`DocumentFragment`](https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment) في واجهة برمجة تطبيقات DOM الأصلية.

تُستخدم الشظايا لدعم المكونات ذات العقد الجذرية المتعددة. وبينما قد تبدو هذه المكونات وكأنها تحتوي على جذور متعددة، فإنها تستخدم وراء الكواليس عقدة شظية كجذر واحد، كأصل للعقد "الجذرية".

تُستخدم الشظايا أيضًا بواسطة مُجمِّع القالب كطريقة لتغليف عقد ديناميكية متعددة، على سبيل المثال تلك التي تم إنشاؤها عبر `v-for` أو `v-if`. يسمح هذا بتمرير تلميحات إضافية إلى خوارزمية التصحيح [VDOM](#virtual-dom). يتم التعامل مع الكثير من هذا داخليًا، ولكن هناك مكان قد تواجه فيه هذا مباشرةً وهو استخدام `key` على علامة `<template>` مع `v-for`. في هذا السيناريو، تتم إضافة `key` كـ [prop](#prop) إلى عقدة VNode المجزأة.

يتم حاليًا عرض عقدة المجزأة إلى DOM كعقد نصية فارغة، على الرغم من أن هذه تفاصيل تنفيذ. قد تواجه عقد النص هذه إذا استخدمت `$el` أو حاولت تشغيل DOM باستخدام واجهات برمجة تطبيقات المتصفح المضمنة.

## مكون وظيفي {#functional-component}

تعريف المكون هو عادةً كائن يحتوي على خيارات. قد لا يبدو الأمر كذلك إذا كنت تستخدم `<script setup>`، ولكن المكون المُصدَّر من ملف `.vue` سيظل كائنًا.

*المكون الوظيفي* هو شكل بديل للمكون يتم إعلانه باستخدام دالة بدلاً من ذلك. تعمل هذه الدالة كـ [دالة تقديم](#render-function) للمكون.

لا يمكن للمكون الوظيفي أن يكون له أي حالة خاصة به. كما أنه لا يمر بدورة حياة المكون المعتادة، لذا لا يمكن استخدام خطافات دورة الحياة. وهذا يجعلها أخف قليلاً من المكونات العادية التي لها حالة.

لمزيد من التفاصيل، راجع:
- [الدليل - وظائف التقديم وJSX - المكونات الوظيفية](/guide/extras/render-function.html#functional-components)

## الرفع {#hoisting}

يستخدم مصطلح *hoisting* لوصف تشغيل قسم من التعليمات البرمجية قبل الوصول إليه، قبل التعليمات البرمجية الأخرى. يتم "رفع" التنفيذ إلى نقطة سابقة.

يستخدم JavaScript عملية hoisting لبعض البنيات، مثل `var` و`import` وإعلانات الوظائف.

في سياق Vue، يطبق مُجمِّع القالب عملية *hoisting ثابتة* لتحسين الأداء. عند تحويل قالب إلى دالة عرض، يمكن إنشاء VNodes التي تتوافق مع المحتوى الثابت مرة واحدة ثم إعادة استخدامها. يتم وصف هذه VNodes الثابتة بأنها hoisted لأنها يتم إنشاؤها خارج دالة العرض، قبل تشغيلها. يتم تطبيق شكل مماثل من عملية hoisting على الكائنات الثابتة أو المصفوفات التي يتم إنشاؤها بواسطة مُجمِّع القالب.

لمزيد من التفاصيل، راجع:
- [دليل - آلية العرض - الرفع الثابت](/guide/extras/rendering-mechanism.html#static-hoisting)

## in-DOM نموذج {#in-dom-template}

توجد طرق مختلفة لتحديد قالب لمكون. في أغلب الحالات، يتم توفير القالب كسلسلة.

يشير مصطلح *قالب داخل DOM* إلى السيناريو الذي يتم فيه توفير القالب في هيئة عقد DOM، بدلاً من سلسلة. ثم يقوم Vue بتحويل عقد DOM إلى سلسلة قالب باستخدام `innerHTML`.

عادةً، يبدأ قالب داخل DOM كعلامة HTML مكتوبة مباشرةً في HTML للصفحة. ثم يقوم المتصفح بتحليلها إلى عقد DOM، والتي يستخدمها Vue بعد ذلك لقراءة `innerHTML`.

لمزيد من التفاصيل، راجع:
- [دليل - إنشاء تطبيق - قالب مكون الجذر في DOM](/guide/essentials/application.html#in-dom-root-component-template)
- [دليل - أساسيات المكونات - تحذيرات تحليل قالب DOM](/guide/essentials/component-basics.html#dom-template-parsing-caveats)
- [خيارات: العرض - قالب](/api/options-rendering.html#template)

## حقن {#inject}

انظر [تقديم / حقن](#provide-inject).

## خطافات دورة الحياة {#lifecycle-hooks}

تمر مثيلات مكون Vue بدورة حياة. على سبيل المثال، يتم إنشاؤها وتركيبها وتحديثها وإلغاء تركيبها.

*خطافات دورة الحياة* هي طريقة للاستماع إلى أحداث دورة الحياة هذه.

باستخدام واجهة برمجة التطبيقات Options، يتم توفير كل خطاف كخيار منفصل، على سبيل المثال `mounted`. تستخدم واجهة برمجة التطبيقات Composition وظائف بدلاً من ذلك، مثل `onMounted()`.

لمزيد من التفاصيل، راجع:
- [دليل - خطافات دورة الحياة](/guide/essentials/lifecycle.html)

## ماكرو {#macro}

انظر [ماكرو المترجم](#macro-compiler).

## فتحة مسماة {#named-slot}

يمكن أن يحتوي المكون على عدة فتحات، يتم التمييز بينها بالاسم. يشار إلى الفتحات بخلاف الفتحة الافتراضية باسم *الفتحات المسماة*.

لمزيد من التفاصيل، راجع:
- [دليل - الفتحات - الفتحات المسماة](/guide/components/slots.html#named-slots)

## خيارات API {#options-api}

يتم تعريف مكونات Vue باستخدام الكائنات. تُعرف خصائص كائنات هذه المكونات باسم *الخيارات*.

يمكن كتابة المكونات بأسلوبين. يستخدم أحد الأسلوبين [Composition API](#composition-api) بالتزامن مع `setup` (إما عبر خيار `setup()` أو `<script setup>`). يستخدم الأسلوب الآخر القليل جدًا من استخدام Composition API المباشر، ويستخدم بدلاً من ذلك خيارات مكونات مختلفة لتحقيق نتيجة مماثلة. يشار إلى خيارات المكونات المستخدمة بهذه الطريقة باسم *Options API*.

تتضمن Options API خيارات مثل `data()` و`computed` و`methods` و`created()`.

يمكن استخدام بعض الخيارات، مثل `props` و`emits` و`inheritAttrs`، عند تأليف المكونات باستخدام أي من APIs. نظرًا لأنها خيارات مكونات، فيمكن اعتبارها جزءًا من Options API. ومع ذلك، نظرًا لاستخدام هذه الخيارات أيضًا بالتزامن مع `setup()`، فمن الأفضل عادةً التفكير فيها باعتبارها مشتركة بين نمطي المكون.

وظيفة `setup()` نفسها هي خيار مكون، لذا *يمكن* وصفها بأنها جزء من واجهة برمجة التطبيقات للخيارات. ومع ذلك، لا يتم استخدام مصطلح `Options API` بهذه الطريقة عادةً. بدلاً من ذلك، تعتبر وظيفة `setup()` جزءًا من واجهة برمجة التطبيقات للتكوين.

## المكون الإضافي {#plugin}

في حين يمكن استخدام مصطلح *plugin* في مجموعة متنوعة من السياقات، فإن Vue لديه مفهوم محدد للمكون الإضافي كطريقة لإضافة وظيفة إلى تطبيق.

تتم إضافة المكونات الإضافية إلى التطبيق عن طريق استدعاء `app.use(plugin)`. المكون الإضافي نفسه عبارة عن دالة أو كائن به دالة `install`. سيتم تمرير هذه الدالة إلى مثيل التطبيق ويمكنها بعد ذلك القيام بكل ما يلزم القيام به.

لمزيد من التفاصيل، راجع:
- [دليل - المكونات الإضافية](/guide/reusability/plugins.html)

## دعم {#prop}

هناك ثلاثة استخدامات شائعة لمصطلح *prop* في Vue:

* خصائص المكوّن
* خصائص VNode
* خصائص الفتحة

*خصائص المكوّن* هي ما يعتقده معظم الناس على أنه خصائص. يتم تعريفها صراحةً بواسطة المكوّن باستخدام إما `defineProps()` أو خيار `props`.

يشير مصطلح *خصائص VNode* إلى خصائص الكائن التي يتم تمريرها كحجة ثانية إلى `h()`. يمكن أن تتضمن هذه خصائص المكوّن، ولكنها يمكن أن تتضمن أيضًا أحداث المكوّن وأحداث DOM وسمات DOM وخصائص DOM. عادةً ما تواجه خصائص VNode فقط إذا كنت تعمل مع وظائف العرض للتلاعب بعقد VNodes مباشرةً.

*خصائص الفتحة* هي الخصائص التي يتم تمريرها إلى فتحة محددة النطاق.

في جميع الحالات، الخصائص هي خصائص يتم تمريرها من مكان آخر.

في حين أن كلمة props مشتقة من كلمة *properties*، فإن مصطلح props له معنى أكثر تحديدًا في سياق Vue. يجب عليك تجنب استخدامه كاختصار للخصائص.

لمزيد من التفاصيل، راجع:
- [دليل - الدعائم](/guide/components/props.html)
- [دليل - وظائف العرض وJSX](/guide/extras/render-function.html)
- [دليل - الفتحات - الفتحات المحددة](/guide/components/slots.html#scoped-slots)

## توفير / حقن {#provide-inject}

`provide` و`inject` هما شكل من أشكال الاتصال بين المكونات.

عندما *يوفر* أحد المكونات قيمة، يمكن لجميع أحفاد هذا المكون اختيار الحصول على هذه القيمة باستخدام `inject`. على عكس الدعائم، لا يعرف المكون المقدم على وجه التحديد أي مكون يتلقى القيمة.

يتم استخدام `provide` و`inject` أحيانًا لتجنب *حفر الدعائم*. يمكن أيضًا استخدامهما كطريقة ضمنية للمكون للتواصل مع محتويات الفتحة الخاصة به.

يمكن أيضًا استخدام `provide` على مستوى التطبيق، مما يجعل القيمة متاحة لجميع المكونات داخل هذا التطبيق.

لمزيد من التفاصيل، راجع:
- [دليل - provide / inject](/guide/components/provide-inject.html)

## تأثير تفاعلي {#reactive-effect}

*التأثير التفاعلي* هو جزء من نظام التفاعل في Vue. يشير إلى عملية تتبع تبعيات الدالة وإعادة تشغيل تلك الدالة عندما تتغير قيم تلك التبعيات.

يعد *التأثير التفاعلي* جزءًا من نظام التفاعل في Vue. وهو يشير إلى عملية تتبع تبعيات الدالة وإعادة تشغيل تلك الدالة عندما تتغير قيم تلك التبعيات.

لا يمكن لـ Vue تتبع التبعيات التفاعلية إلا داخل التأثير التفاعلي. إذا تمت قراءة قيمة الخاصية خارج التأثير التفاعلي، فسوف "تفقد" التفاعلية، بمعنى أن Vue لن تعرف ماذا تفعل إذا تغيرت تلك الخاصية لاحقًا.

المصطلح مشتق من "التأثير الجانبي". إن استدعاء دالة التأثير هو تأثير جانبي لتغيير قيمة الخاصية.

لمزيد من التفاصيل، راجع:
- [دليل - التفاعلية بعمق](/guide/extras/reactivity-in-depth.html)

## التفاعلية {#reactivity}

بشكل عام، يشير مصطلح *التفاعلية* إلى القدرة على تنفيذ الإجراءات تلقائيًا استجابةً لتغييرات البيانات. على سبيل المثال، تحديث DOM أو تقديم طلب شبكة عند تغيير قيمة بيانات.

في سياق Vue، تُستخدم التفاعلية لوصف مجموعة من الميزات. تتحد هذه الميزات لتكوين *نظام تفاعلية*، والذي يتم عرضه عبر [واجهة برمجة تطبيقات التفاعلية](#reactivity-api).

هناك طرق مختلفة يمكن من خلالها تنفيذ نظام التفاعلية. على سبيل المثال، يمكن القيام بذلك من خلال التحليل الثابت للكود لتحديد تبعياته. ومع ذلك، لا يستخدم Vue هذا الشكل من نظام التفاعلية.

بدلاً من ذلك، يتتبع نظام التفاعلية في Vue الوصول إلى الخصائص في وقت التشغيل. وهو يفعل ذلك باستخدام كل من غلافات الوكيل ووظائف الحصول/التعيين للخصائص.

لمزيد من التفاصيل، راجع:
- [دليل - أساسيات التفاعلية](/guide/essentials/reactivity-fundamentals.html)
- [دليل - التفاعلية بالتفصيل](/guide/extras/reactivity-in-depth.html)

## واجهة برمجة التطبيقات التفاعلية {#reactivity-api}

*واجهة برمجة تطبيقات التفاعل* عبارة عن مجموعة من وظائف Vue الأساسية المرتبطة بـ [reactive](#reactiveity). ويمكن استخدامها بشكل مستقل عن المكونات. وهي تتضمن وظائف مثل `ref()` و`reactive()` و`computed()` و`watch()` و`watchEffect()`.

واجهة برمجة تطبيقات التفاعل هي مجموعة فرعية من واجهة برمجة تطبيقات التكوين.

لمزيد من التفاصيل، راجع:
- [واجهة برمجة تطبيقات التفاعل: الأساسية](/api/reactivity-core.html)
- [واجهة برمجة تطبيقات التفاعل: الأدوات المساعدة](/api/reactivity-utilities.html)
- [واجهة برمجة تطبيقات التفاعل: المتقدمة](/api/reactivity-advanced.html)

## مرجع {#ref}
> يتعلق هذا الإدخال باستخدام `ref` للتفاعلية. بالنسبة لخاصية `ref` المستخدمة في القوالب، راجع [template ref](#template-ref) بدلاً من ذلك.

"يعتبر `ref` جزءًا من نظام التفاعل في Vue. وهو عبارة عن كائن له خاصية تفاعلية واحدة تسمى `value`."

هناك أنواع مختلفة من المراجع. على سبيل المثال، يمكن إنشاء المراجع باستخدام `ref()` و`shallowRef()` و`computed()` و`customRef()`. يمكن استخدام الدالة `isRef()` للتحقق مما إذا كان الكائن مرجعًا، ويمكن استخدام `isReadonly()` للتحقق مما إذا كان المرجع يسمح بإعادة التعيين المباشر لقيمته.

لمزيد من التفاصيل، راجع:
- [دليل - أساسيات التفاعلية](/guide/essentials/reactivity-fundamentals.html)
- [واجهة برمجة تطبيقات التفاعلية: الأساسية](/api/reactivity-core.html)
- [واجهة برمجة تطبيقات التفاعلية: الأدوات المساعدة](/api/reactivity-utilities.html)
- [واجهة برمجة تطبيقات التفاعلية: المتقدمة](/api/reactivity-advanced.html)


## وظيفة العرض {#render-function}

*وظيفة العرض* هي جزء من أحد المكونات التي تولد العقد الافتراضية المستخدمة أثناء العرض. يتم تجميع القوالب إلى وظائف عرض.

لمزيد من التفاصيل، راجع:
- [الدليل - وظائف العرض وJSX](/guide/extras/render-function.html)

## المجدول {#scheduler}

*المجدول* هو جزء من مكونات Vue الداخلية التي تتحكم في توقيت تشغيل [التأثيرات التفاعلية](#reactive-effect).

عندما تتغير الحالة التفاعلية، لا يقوم Vue بتشغيل تحديثات العرض على الفور. بدلاً من ذلك، يقوم بتجميعها معًا باستخدام قائمة انتظار. وهذا يضمن إعادة عرض المكون مرة واحدة فقط، حتى إذا تم إجراء تغييرات متعددة على البيانات الأساسية.

[Watchers](/guide/essentials/watchers.html) يتم تجميعها أيضًا باستخدام قائمة انتظار المجدول. سيتم تشغيل المراقبين الذين لديهم `flush: 'pre'` (الافتراضي) قبل عرض المكون، بينما سيتم تشغيل المراقبين الذين لديهم `flush: 'post'` بعد عرض المكون.

تُستخدم الوظائف في المجدول أيضًا لأداء مهام داخلية أخرى مختلفة، مثل تشغيل بعض [lifecycle hooks](#lifecycle-hooks) وتحديث [template refs](#template-ref).

## فتحة النطاق {#scoped-slot}

يُستخدم مصطلح *فتحة ذات نطاق* للإشارة إلى [فتحة](#فتحة) تستقبل [props](#prop).

تاريخيًا، أحدثت Vue تمييزًا أكبر بين الفتحات ذات النطاق وغير ذات النطاق. وإلى حد ما، يمكن اعتبارهما ميزتين منفصلتين، موحدتين خلف بناء جملة قالب مشترك.

في Vue 3، تم تبسيط واجهات برمجة تطبيقات الفتحات لجعل جميع الفتحات تتصرف مثل الفتحات ذات النطاق. ومع ذلك، غالبًا ما تختلف حالات الاستخدام للفتحات ذات النطاق وغير ذات النطاق، لذلك لا يزال المصطلح مفيدًا كطريقة للإشارة إلى الفتحات ذات الخصائص.

لا يمكن استخدام الخصائص التي يتم تمريرها إلى فتحة إلا داخل منطقة محددة من القالب الرئيسي، وهي المسؤولة عن تحديد محتويات الفتحة. تتصرف هذه المنطقة من القالب كنطاق متغير للخصائص، ومن هنا جاء اسم "فتحة ذات نطاق".

لمزيد من التفاصيل، راجع:
- [الدليل - الفتحات - الفتحات المحددة](/guide/components/slots.html#scoped-slots)

## SFC {#sfc}

انظر [مكون الملف الفردي](#single-file-component).

## أثر جانبي {#side-effect}

لا يقتصر مصطلح *التأثير الجانبي* على Vue. فهو يُستخدم لوصف العمليات أو الوظائف التي تقوم بشيء يتجاوز نطاقها المحلي.

على سبيل المثال، في سياق تعيين خاصية مثل `user.name = null`، من المتوقع أن يؤدي هذا إلى تغيير قيمة `user.name`. وإذا كان يفعل أيضًا شيئًا آخر، مثل تشغيل نظام التفاعل في Vue، فسيتم وصف هذا بأنه تأثير جانبي. هذا هو أصل مصطلح [التأثير التفاعلي](#reactive-effect) داخل Vue.

عندما يتم وصف دالة بأنها ذات تأثيرات جانبية، فهذا يعني أن الدالة تقوم بنوع من الإجراءات التي يمكن ملاحظتها خارج الدالة، بصرف النظر عن مجرد إرجاع قيمة. قد يعني هذا أنها تقوم بتحديث قيمة في الحالة، أو تشغيل طلب شبكة.

غالبًا ما يتم استخدام المصطلح عند وصف العرض أو الخصائص المحسوبة. يُعتبر من أفضل الممارسات للعرض عدم وجود آثار جانبية. وبالمثل، يجب ألا يكون لدالة الحصول على الخاصية المحسوبة أي آثار جانبية.

## مكون الملف الواحد {#single-file-component}

يشير مصطلح *مكون الملف الفردي*، أو SFC، إلى تنسيق الملف `.vue` المستخدم بشكل شائع لمكونات Vue.

انظر أيضًا:
- [دليل - مكونات الملف الفردي](/guide/scaling-up/sfc.html)
- [مواصفات بناء جملة SFC](/api/sfc-spec.html)

## فتحة {#slot}

تُستخدم الفتحات لتمرير المحتوى إلى المكونات الفرعية. بينما تُستخدم الدعائم لتمرير قيم البيانات، تُستخدم الفتحات لتمرير محتوى أكثر ثراءً يتكون من عناصر HTML ومكونات Vue الأخرى.

لمزيد من التفاصيل، راجع:
- [دليل - الفتحات](/guide/components/slots.html)

## قالب مرجعي {#template-ref}

يشير مصطلح *template ref* إلى استخدام سمة `ref` على علامة داخل قالب. بعد عرض المكون، تُستخدم هذه السمة لملء خاصية مقابلة إما بعنصر HTML أو بمثيل المكون الذي يتوافق مع العلامة في القالب.

إذا كنت تستخدم واجهة برمجة التطبيقات Options، فسيتم عرض المراجع عبر خصائص الكائن `$refs`.

باستخدام واجهة برمجة التطبيقات Composition، تملأ مراجع القالب [ref](#ref) تفاعلية بنفس الاسم.

لا ينبغي الخلط بين مراجع القالب والمراجع التفاعلية الموجودة في نظام التفاعلية الخاص بـ Vue.

لمزيد من التفاصيل، راجع:
- [الدليل - مراجع القالب](/guide/essentials/template-refs.html)

## VDOM {#vdom}

انظر [DOM الافتراضي](#virtual-dom).

## DOM افتراضي {#virtual-dom}

لا يقتصر مصطلح *DOM الافتراضي* (VDOM) على Vue. فهو نهج شائع يستخدمه العديد من أطر عمل الويب لإدارة التحديثات التي تطرأ على واجهة المستخدم.

تستخدم المتصفحات شجرة من العقد لتمثيل الحالة الحالية للصفحة. ويشار إلى هذه الشجرة، وواجهات برمجة تطبيقات JavaScript المستخدمة للتفاعل معها، باسم *نموذج كائن المستند* أو *DOM*.

يعد التلاعب بـ DOM عقبة رئيسية في الأداء. ويوفر DOM الافتراضي استراتيجية واحدة لإدارة ذلك.

بدلاً من إنشاء عقد DOM بشكل مباشر، تولد مكونات Vue وصفًا لعقد DOM التي ترغب في الحصول عليها. هذه الوصفات عبارة عن كائنات JavaScript بسيطة، تُعرف باسم VNodes (عقد DOM الافتراضية). إن إنشاء VNodes رخيص نسبيًا.

في كل مرة يتم فيها إعادة عرض أحد المكونات، تتم مقارنة شجرة VNodes الجديدة بالشجرة السابقة لـ VNodes ثم يتم تطبيق أي اختلافات على DOM الحقيقي. إذا لم يتغير شيء، فلا داعي لتعديل DOM.

يستخدم Vue نهجًا هجينًا نطلق عليه [DOM افتراضي مُستنير بالمُجمِّع](/guide/extras/rendering-mechanism.html#compiler-informed-virtual-dom). يتمكن مُجمِّع قالب Vue من تطبيق تحسينات الأداء استنادًا إلى التحليل الثابت للقالب. وبدلاً من إجراء مقارنة كاملة بين أشجار VNode القديمة والجديدة للمكون في وقت التشغيل، يمكن لـ Vue استخدام المعلومات المستخرجة بواسطة المُجمِّع لتقليل المقارنة إلى أجزاء الشجرة التي يمكن أن تتغير بالفعل.

لمزيد من التفاصيل، راجع:
- [دليل - آلية العرض](/guide/extras/rendering-mechanism.html)
- [دليل - وظائف العرض وJSX](/guide/extras/render-function.html)

## VNode {#vnode}

*VNode* عبارة عن *عقدة DOM افتراضية*. ويمكن إنشاؤها باستخدام الدالة [`h()`](/api/render-function.html#h).

راجع [virtual DOM](#virtual-dom) لمزيد من المعلومات.

## مكون الويب {#web-component}

معيار *مكونات الويب* عبارة عن مجموعة من الميزات التي تم تنفيذها في متصفحات الويب الحديثة.

مكونات Vue ليست مكونات ويب، ولكن يمكن استخدام `defineCustomElement()` لإنشاء [عنصر مخصص](#custom-element) من مكون Vue. يدعم Vue أيضًا استخدام عناصر مخصصة داخل مكونات Vue.

لمزيد من التفاصيل، راجع:
- [الدليل - Vue ومكونات الويب](/guide/extras/web-components.html)
